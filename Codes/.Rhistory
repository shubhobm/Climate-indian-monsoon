head(n)
cov(s01*((norm1/norm) %*% ones(1,2)))
n = (norm1/norm) %*% ones(1,2)
head(n)
cov(s01*n)
cov(s01)
cov(s1)
cov(s)
apply(s01*n, 1, mean)
apply(s01*n, 2, mean)
apply(s01/n, 2, mean)
diag(25,1) %*% var(s01*n)
diag(25,1) %*% cov(s01*n)
cov(s01*n)
diag(c(25,1)) %*% cov(s01*n)
diag(c(25,1)) %*% cov(s01) * var(n)
head(n)
var(n[,1])
var(n)
?cov
cov(s01, norm1/norm)
cov(s01, norm/norm1)
var(s01)
var(s01*n)
head(n)
cov(s01,n)
diag(c(25,1)) %*% var(s01*n)
var(s01) * var(n)
a = matrix(rnorm(2e3), ncol=2)
b=rnorm(1e3)
cov(a,b)
cov(a*b)
cov(a)*var(b)
cov(s01*n)
cov(s01)*var(n)
cov(s01)*cov(n)
cov(a)
var(b)
b1=ones(1,2) %*% b
b1=ones(,) %*% b
b1=ones(2,1) %*% b
head(b1)
b1=t(ones(2,1) %*% b)
head(b1)
cov(a*b1)
cov(a) * cov(b1)
cov(b1)
cov(s01*n)
mean(s01[,1])
var(s01[,1])
var(s01[,1]*n[,1])
mean((s01[,1]*n[,1])^2)
var(s01[,1] * mean(n[,1]^2))
var(s01[,1]) * mean(n[,1]^2)
var(s01[,1])
mean(s01[,1]^2)
mean(s01[,1]^2) * mean(n[,1]^2)
mean(s01[,1]^2) * mean(n[,1]^2) - (mean(s01[,1])*mean(n[,1]))^2
mean(s01[,1]^2) * mean(n[,1]^2) - (mean(s01[,1]*n[,1]))^2
var(s01[,1] * n[,1])
mean(s01[,1]^2 * n[,1]^2) - (mean(s01[,1]*n[,1]))^2
mean(s01[,1]^2 * n[,1]^2)
mean(s01[,1]^2)
mean(n[,1]^2)
mean(s01[,1]^2 * n[,1]^2) / mean(s01[,1]^2)
mean(s01[,1]^2 * n[,1]^2) / mean(n[,1]^2)
cov(s01,n[,1])
cov(sd)
cov(s)/cov(sd)
n = 1e3
set.seed(120214)
# x = rnorm(n)
# X = cbind(x, 2*x)
# X = scale(X, scale=F)
Gamma = matrix(c(1,-1,1,1), nrow=2)/sqrt(2)
sig = Gamma %*% diag(c(25,1)) %*% t(Gamma)
X = my.mvrnorm(n, mu=c(0,0), Sig=sig)
# x = runif(n)
# X = cbind(x, x+rnorm(n, sd=.001))
# X = scale(X, scale=F)
# PCA before contamination
(p.pure <- princomp(X)); p.pure$loadings
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1
Xrank = X1 * (max(d1[,3]) - d1[,3])
cov(Xrank)
cov(X)
n = 1e3
set.seed(120214)
# x = rnorm(n)
# X = cbind(x, 2*x)
# X = scale(X, scale=F)
Gamma = matrix(c(1,-1,1,1), nrow=2)/sqrt(2)
sig = Gamma %*% diag(c(25,1)) %*% t(Gamma)
X = my.mvrnorm(n, mu=c(0,0), Sig=2*sig)
# x = runif(n)
# X = cbind(x, x+rnorm(n, sd=.001))
# X = scale(X, scale=F)
# PCA before contamination
(p.pure <- princomp(X)); p.pure$loadings
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1
Xrank = X1 * (max(d1[,3]) - d1[,3])
cov(Xrank)
a=rchisq(1000,1)
b=rchisq(1000,1)
cov(a/(a+b),b/(a+b))
corr(a/(a+b),b/(a+b))
cor(a/(a+b),b/(a+b))
c=rchisq(1000,1)
s=a+b+c
cor(a/s,b/s)
cor(a/s,b/s,c/s)
cov(cbind(a/s,b/s,c/s))
cor(cbind(a/s,b/s,c/s))
install.packages("fastM")
require(fastM)
TYLERshape(matrix(rnorm(100),ncol=2))
X = matrix(rnorm(1e3), ncol=2)
cov(X)
TYLERshape(X)
X[91:100,] = X[91:100,] + 50
cov(X)
TYLERshape(X)
?TYLERshape
Sys.info()[4]
acos(NA)
acos(NaN)
X=MATRIC(0,2,2)
x=matrix(0,2,2)
x[,2]
class(x[,2])
pbp.2014 <- read.csv("C:/Study/My projects/Depth-scatter/Data/pbp-2014.csv")
View(pbp.2014)
nfl2014stats <- read.csv("C:/Study/My projects/Depth-scatter/Data/nfl2014stats.csv")
View(nfl2014stats)
nfl2013stats <- read.csv("C:/Study/My projects/Depth-scatter/Data/nfl2013stats.csv")
View(nfl2013stats)
plot(nfl2013stats[,5:8])
nfl2013lines <- read.csv("C:/Study/My projects/Depth-scatter/Data/nfl2013lines.csv")
View(nfl2013lines)
players_2013.12.12 <- read.csv("C:/Study/My projects/Depth-scatter/Data/players_2013-12-12.csv")
View(players_2013.12.12)
citation()
X=-2:.1:2
X=seq(-2,2,.01)
y = ifelse(abs(X)>1, 1, 3X^2-3X^4+X^6)
?abs
y = ifelse(abs(X)>1, 1, 3*X^2-3*X^4+X^6)
plot(y~X, tyle="l")
plot(y~X, type="l")
plot(y~X, type="l")
y=1/(1+X^2)
plot(y~X, type="l")
y=1/(1+abs(X))
plot(y~X, type="l")
train <- read.csv("C:/Study/My projects/Kaggle-restaurant/train.csv")
View(train)
hist(train$revenue)
summary(train$City)
summary(lmrevenow~., data=train[,-c(1:3)])
summary(lm(revenue~., data=train[,-c(1:3)]))
pairs(train[,21:25])
pairs(train[,21:30])
install.packages("kernlab")
# another example using the iris
data(iris)
test <- sample(1:150,20)
kpc <- kpca(~.,data=iris[-test,-5],kernel="rbfdot",
kpar=list(sigma=0.2),features=2)
#print the principal component vectors
pcv(kpc)
#plot the data projection on the components
plot(rotated(kpc),col=as.integer(iris[-test,5]),
xlab="1st Principal Component",ylab="2nd Principal Component")
library(kernlab)
data(iris)
test <- sample(1:150,20)
kpc <- kpca(~.,data=iris[-test,-5],kernel="rbfdot",
kpar=list(sigma=0.2),features=2)
#print the principal component vectors
pcv(kpc)
#plot the data projection on the components
plot(rotated(kpc),col=as.integer(iris[-test,5]),
xlab="1st Principal Component",ylab="2nd Principal Component")
?pcv
?rotated
west_nile_v5_400_2layer_mod2 <- read.csv("C:/Study/My projects/Kaggle-mosquito/codes/west_nile_v5_400_2layer_mod2.csv")
View(west_nile_v5_400_2layer_mod2)
GAM6_eNumMosRF_day4 <- read.csv("C:/Study/My projects/Kaggle-mosquito/codes/GAM6_eNumMosRF_day4.csv")
View(GAM6_eNumMosRF_day4)
khichuri = west_nile_v5_400_2layer_mod2
khichuri[,2] = (khichuri[,2] + GAM6_eNumMosRF_day4[,2])/2
options("scipen"=100, "digits"=8)
write.csv(khichuri,"khichuri.csv",row.names=FALSE,quote=FALSE)
west_nile_v55044 <- read.csv("C:/Users/Subho/Downloads/west_nile_v55044.csv")
View(west_nile_v55044)
west_nile_v6 <- read.csv("C:/Study/My projects/Kaggle-mosquito/codes/west_nile_v6.csv")
View(west_nile_v6)
khichuri = west_nile_v6
khichuri[,2] = (khichuri[,2] + west_nile_v55044[,2])/2
options("scipen"=100, "digits"=8)
write.csv(khichuri,"khichuri.csv",row.names=FALSE,quote=FALSE)
rm(list=ls())
#setwd("\\\\dfs.com/root/Dept-Decision/Dept-Users/Majumdar/Rain")
setwd('C:/Study/My projects/Climate-indian monsoon/Codes')
source('misc_functions.R')
library(rrcov)
library(fda.usc)
library(lme4)
library(MuMIn)
library(doSNOW)
library(parallel)
# read in data
rainsmall = read.csv("../data/rainsmall.csv")
# check full model
rainsmall[-(1:3)] = scale(rainsmall[-(1:3)])
varnames = names(rainsmall)[-(1:3)]
formula = paste(varnames, collapse="+")
random_terms = "+ (1|year)"
formula = as.formula(paste("log(PRCP+1) ~", formula, random_terms))
mod.full = lmer(formula, data=rainsmall)
summary(mod.full)
anova(mod.full)
r.squaredGLMM(mod.full)
read.table('wild_ntothepoint05.txt', header=T)
read.table('wild_ntothepoint05.txt', header=T)
Cn.frame = read.table('wild_ntothepoint05.txt', header=T)
noneCn = Cn.frame$Cn[which(Cn.frame$DroppedVar == "<none>")]
varnames = names(rainsmall)[-(1:3)]
varnames
data.frame(c(varnames, "<none>"))
merge(data.frame(c(varnames, "<none>"), Cn.frame)
)
nameframe = data.frame(c(varnames, "<none>"))
names(nameframe) = "DroppedVar"
merge(nameframe, Cn.frame)
y = getME(mod.full, 'y')
fixed = getME(mod.full, 'X') %*% fixef(mod.full)
eta = unlist(ranef(mod.full))
Z = t(as.matrix(getME(mod.full,'Zt')))
random = Z %*% eta
r = y - fixed - random
# bootstrap parameters
n = nrow(rainsmall)
nr = length(eta)
p = ncol(rainsmall)-3
sdn = n^(.05)
sdr = nr^(.05)
loopfun = function(i){
require(lme4)
require(fda.usc)
iyb = fixed + (Z %*% (rnorm(nr)*sdr*eta) + rnorm(n)*sdn*r)/sqrt(1 - p/n)
SSPvec = rep(0,p)
# loop for all variables
for(j in 1:p){
# build model
jformula = paste(varnames[-j], collapse="+")
jformula = as.formula(paste("iyb ~", jformula, random_terms))
ijmod = lmer(jformula, data=rainsmall)
# extract coef and extend to lengthp by appending 0's
ibeta.j = as.numeric(coef(ijmod)$year[1,-1])
ibeta.j.full = rep(0,p)
ibeta.j.full[-j] = ibeta.j
# get depth-based criterion
SSPvec[j] = mdepth.RP(ibeta.j.full, beta.mat)$dep
}
SSPvec
}
# loop for full model bootstrap
# to get bootstrap distribution of parameters
nboot = 1e3
SSPmat = matrix(0, nrow=nboot, ncol=p+1)
SSPmat.d = SSPmat
beta.mat = matrix(0, nrow=nboot, ncol=p)
set.seed(07152015)
# create progress bar
pb <- txtProgressBar(min = 0, max = nboot, style = 3)
for(i in 1:nboot){
iyb = fixed + (Z %*% (rnorm(nr)*sdr*eta) + rnorm(n)*sdn*r)/sqrt(1 - p/n)
iformula = paste(varnames, collapse="+")
iformula = as.formula(paste("iyb ~", iformula, random_terms))
imod = lmer(iformula, data=rainsmall)
beta.mat[i,] = as.numeric(coef(imod)$year[1,-1])
setTxtProgressBar(pb, i)
}
close(pb)
SSPmat.d[,p+1] = mdepth.RP(beta.mat, beta.mat)$dep
# run function in parallel
cl <- makeCluster(detectCores()-2)
registerDoSNOW(cl)
system.time(SSPtab <- foreach(i=1:nboot) %dopar% loopfun(i))
SSPmat.d[,1:p] = matrix(unlist(SSPtab), ncol=p, byrow=T)
stopCluster(cl)
# get p-values
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1], alternative="less")$p.value
}
Cn.frame = data.frame(DroppedVar = c(paste("-", names(data.frame(getME(mod.full, 'X')))[-1]), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
noneCn = Cn.frame$Cn[which(Cn.frame$DroppedVar == "<none>")]
which.final = which(apply(SSPmat.d, 2, mean) < noneCn & pVal < 0.05)
fixed.final = paste(varnames[which.final], collapse="+")
form.final = as.formula(paste("log(PRCP+1) ~", fixed.final, random_terms))
mod.final = lmer(form.final, data=rainsmall)
summary(mod.final)
anova(mod.final)
r.squaredGLMM(mod.final)
anova(mod.final, mod.full)
set.seed(07222015)
estyrs = 2003:2012
ntest = length(testyrs)
pred.mat = matrix(0, ncol=2, nrow=ntest)
for (i in 1:ntest){
iyr = testyrs[i]
itrain = which(rainsmall$year >= iyr-25 & rainsmall$year < iyr)
itest = which(rainsmall$year == iyr)
testX = rainsmall[itest,-c(1:3)]
#mod.full.train = lm(as.formula(paste("log(PRCP+1) ~", fixed.full)), data=rainsmall, subset=itrain)
#mod.final.train = lm(as.formula(paste("log(PRCP+1) ~", fixed.final)), data=rainsmall, subset=itrain)
mod.full.train = lmer(form.full, data=rainsmall, subset=itrain)
mod.final.train = lmer(form.final, data=rainsmall, subset=itrain)
ytest = log(rainsmall$PRCP[itest]+1)
yhat.full = as.matrix(cbind(1, testX)) %*% as.numeric(fixef(mod.full.train))
pred.mat[i,1] = mean((ytest - yhat.full)^2)
yhat.final = as.matrix(cbind(1, testX[,which.final])) %*% as.numeric(fixef(mod.final.train))
pred.mat[i,2] = mean((ytest - yhat.final)^2)
}
plot(pred.mat[,1]~testyrs, type="b", ylim=c(0,ceiling(max(pred.mat[,1]))), lwd=2,
xlab="year", ylab="MSE of BLUE", main="25 year rolling prediction of next year's median rainfall")
lines(pred.mat[,2]~testyrs, type="b", lty=2, lwd=2)
legend("topleft", c("Full model", "Reduced model"), lty=1:2, lwd=2)
plot(density(ytest), xlim=c(-2,10), ylim=c(0,.5), lwd=2,
xlab="log(PRCP+1)", ylab="density", main="Year 2012")
lines(density(yhat.full), col='red', lwd=2)
lines(density(yhat.final), col='blue', lwd=2)
legend("topright", c("Truth", "Full model pred", "Reduced model pred"),
col=c('black','red','blue'), lty=1, lwd=2)
testyrs = 2003:2012
ntest = length(testyrs)
pred.mat = matrix(0, ncol=2, nrow=ntest)
for (i in 1:ntest){
iyr = testyrs[i]
itrain = which(rainsmall$year >= iyr-25 & rainsmall$year < iyr)
itest = which(rainsmall$year == iyr)
testX = rainsmall[itest,-c(1:3)]
#mod.full.train = lm(as.formula(paste("log(PRCP+1) ~", fixed.full)), data=rainsmall, subset=itrain)
#mod.final.train = lm(as.formula(paste("log(PRCP+1) ~", fixed.final)), data=rainsmall, subset=itrain)
mod.full.train = lmer(form.full, data=rainsmall, subset=itrain)
mod.final.train = lmer(form.final, data=rainsmall, subset=itrain)
ytest = log(rainsmall$PRCP[itest]+1)
yhat.full = as.matrix(cbind(1, testX)) %*% as.numeric(fixef(mod.full.train))
pred.mat[i,1] = mean((ytest - yhat.full)^2)
yhat.final = as.matrix(cbind(1, testX[,which.final])) %*% as.numeric(fixef(mod.final.train))
pred.mat[i,2] = mean((ytest - yhat.final)^2)
}
# check full model
rainsmall[-(1:3)] = scale(rainsmall[-(1:3)])
varnames = names(rainsmall)[-(1:3)]
fixed.full = paste(varnames, collapse="+")
random_terms = "+ (1|year)"
form.full = as.formula(paste("log(PRCP+1) ~", fixed.full, random_terms))
mod.full = lmer(form.full, data=rainsmall)
summary(mod.full)
anova(mod.full)
r.squaredGLMM(mod.full)
noneCn = Cn.frame$Cn[which(Cn.frame$DroppedVar == "<none>")]
which.final = which(apply(SSPmat.d, 2, mean) < noneCn & pVal < 0.05)
fixed.final = paste(varnames[which.final], collapse="+")
form.final = as.formula(paste("log(PRCP+1) ~", fixed.final, random_terms))
mod.final = lmer(form.final, data=rainsmall)
summary(mod.final)
anova(mod.final)
r.squaredGLMM(mod.final)
anova(mod.final, mod.full)
testyrs = 2003:2012
ntest = length(testyrs)
pred.mat = matrix(0, ncol=2, nrow=ntest)
for (i in 1:ntest){
iyr = testyrs[i]
itrain = which(rainsmall$year >= iyr-25 & rainsmall$year < iyr)
itest = which(rainsmall$year == iyr)
testX = rainsmall[itest,-c(1:3)]
#mod.full.train = lm(as.formula(paste("log(PRCP+1) ~", fixed.full)), data=rainsmall, subset=itrain)
#mod.final.train = lm(as.formula(paste("log(PRCP+1) ~", fixed.final)), data=rainsmall, subset=itrain)
mod.full.train = lmer(form.full, data=rainsmall, subset=itrain)
mod.final.train = lmer(form.final, data=rainsmall, subset=itrain)
ytest = log(rainsmall$PRCP[itest]+1)
yhat.full = as.matrix(cbind(1, testX)) %*% as.numeric(fixef(mod.full.train))
pred.mat[i,1] = mean((ytest - yhat.full)^2)
yhat.final = as.matrix(cbind(1, testX[,which.final])) %*% as.numeric(fixef(mod.final.train))
pred.mat[i,2] = mean((ytest - yhat.final)^2)
}
plot(pred.mat[,1]~testyrs, type="b", ylim=c(0,ceiling(max(pred.mat[,1]))), lwd=2,
xlab="year", ylab="MSE of BLUE", main="25 year rolling prediction of next year's median rainfall")
lines(pred.mat[,2]~testyrs, type="b", lty=2, lwd=2)
legend("topleft", c("Full model", "Reduced model"), lty=1:2, lwd=2)
plot(density(ytest), xlim=c(-2,10), ylim=c(0,.5), lwd=2,
xlab="log(PRCP+1)", ylab="density", main="Year 2012")
lines(density(yhat.full), col='red', lwd=2)
lines(density(yhat.final), col='blue', lwd=2)
legend("topright", c("Truth", "Full model pred", "Reduced model pred"),
col=c('black','red','blue'), lty=1, lwd=2)
txtStart('log_lmmselect_wild.txt')
library(TeachingDemos)
mod6 = lmer(log(PRCP+1)~TMAX+ELEVATION+TempAnomaly+del_TT_Deg_Celsius+v_wind_850+Nino34,
data=rainsmall)
mod6 = lmer(log(PRCP+1)~TMAX+ELEVATION+TempAnomaly+del_TT_Deg_Celsius+v_wind_850+Nino34+(1|year),
data=rainsmall)
summary(mod6)
r.squaredGLMM(mod6)
mod.final = mod6
testyrs = 2003:2012
ntest = length(testyrs)
pred.mat = matrix(0, ncol=2, nrow=ntest)
for (i in 1:ntest){
iyr = testyrs[i]
itrain = which(rainsmall$year >= iyr-25 & rainsmall$year < iyr)
itest = which(rainsmall$year == iyr)
testX = rainsmall[itest,-c(1:3)]
#mod.full.train = lm(as.formula(paste("log(PRCP+1) ~", fixed.full)), data=rainsmall, subset=itrain)
#mod.final.train = lm(as.formula(paste("log(PRCP+1) ~", fixed.final)), data=rainsmall, subset=itrain)
mod.full.train = lmer(form.full, data=rainsmall, subset=itrain)
mod.final.train = lmer(form.final, data=rainsmall, subset=itrain)
ytest = log(rainsmall$PRCP[itest]+1)
yhat.full = as.matrix(cbind(1, testX)) %*% as.numeric(fixef(mod.full.train))
pred.mat[i,1] = mean((ytest - yhat.full)^2)
yhat.final = as.matrix(cbind(1, testX[,which.final])) %*% as.numeric(fixef(mod.final.train))
pred.mat[i,2] = mean((ytest - yhat.final)^2)
}
plot(pred.mat[,1]~testyrs, type="b", ylim=c(0,ceiling(max(pred.mat[,1]))), lwd=2,
xlab="year", ylab="MSE of BLUE", main="25 year rolling prediction of next year's median rainfall")
lines(pred.mat[,2]~testyrs, type="b", lty=2, lwd=2)
legend("topleft", c("Full model", "Reduced model"), lty=1:2, lwd=2)
txtStart('log_lmmselect_wild.txt')
noneCn = Cn.frame$Cn[which(Cn.frame$DroppedVar == "<none>")]
which.final = which(apply(SSPmat.d, 2, mean) < noneCn & pVal < 0.05)
fixed.final = paste(varnames[which.final], collapse="+")
form.final = as.formula(paste("log(PRCP+1) ~", fixed.final, random_terms))
mod.final = lmer(form.final, data=rainsmall)
summary(mod.final)
anova(mod.final)
r.squaredGLMM(mod.final)
anova(mod.final, mod.full)
## 6-variable model
mod6 = lmer(log(PRCP+1)~TMAX+ELEVATION+TempAnomaly+del_TT_Deg_Celsius+v_wind_850+Nino34+(1|year),
data=rainsmall)
summary(mod6)
r.squaredGLMM(mod6)
txtStop()
form6 = log(PRCP+1)~TMAX+ELEVATION+TempAnomaly+del_TT_Deg_Celsius+v_wind_850+Nino34+(1|year)
mod6 = lmer(form6, data=rainsmall)
summary(mod6)
r.squaredGLMM(mod6)
names(whichX)
names(testX)
which6 = c(3,4,6,8,14,35)
testyrs = 2003:2012
ntest = length(testyrs)
pred.mat = matrix(0, ncol=2, nrow=ntest)
which6 = c(3,4,6,8,14,35)
for (i in 1:ntest){
iyr = testyrs[i]
itrain = which(rainsmall$year >= iyr-25 & rainsmall$year < iyr)
itest = which(rainsmall$year == iyr)
testX = rainsmall[itest,-c(1:3)]
#mod.full.train = lm(as.formula(paste("log(PRCP+1) ~", fixed.full)), data=rainsmall, subset=itrain)
#mod.final.train = lm(as.formula(paste("log(PRCP+1) ~", fixed.final)), data=rainsmall, subset=itrain)
mod.full.train = lmer(form.full, data=rainsmall, subset=itrain)
mod.final.train = lmer(form6, data=rainsmall, subset=itrain)
ytest = log(rainsmall$PRCP[itest]+1)
yhat.full = as.matrix(cbind(1, testX)) %*% as.numeric(fixef(mod.full.train))
pred.mat[i,1] = mean((ytest - yhat.full)^2)
yhat.final = as.matrix(cbind(1, testX[,which6])) %*% as.numeric(fixef(mod.final.train))
pred.mat[i,2] = mean((ytest - yhat.final)^2)
}
plot(pred.mat[,1]~testyrs, type="b", ylim=c(0,ceiling(max(pred.mat[,1]))), lwd=2,
xlab="year", ylab="MSE of BLUE", main="25 year rolling prediction of next year's median rainfall")
lines(pred.mat[,2]~testyrs, type="b", lty=2, lwd=2)
legend("topleft", c("Full model", "Reduced model"), lty=1:2, lwd=2)
plot(density(ytest), xlim=c(-2,10), ylim=c(0,.5), lwd=2,
xlab="log(PRCP+1)", ylab="density", main="Year 2012")
lines(density(yhat.full), col='red', lwd=2)
lines(density(yhat.final), col='blue', lwd=2)
legend("topright", c("Truth", "Full model pred", "Reduced model pred"),
col=c('black','red','blue'), lty=1, lwd=2)
plot(density(ytest), xlim=c(-2,10), ylim=c(0,.5), lwd=2,
xlab="log(PRCP+1)", ylab="density", main="Year 2012")
lines(density(yhat.full), col='red', lwd=2)
lines(density(yhat.final), col='blue', lwd=2)
legend("topright", c("Truth", "Full model pred", "6-var model pred"),
col=c('black','red','blue'), lty=1, lwd=2)
plot(pred.mat[,1]~testyrs, type="b", ylim=c(0,ceiling(max(pred.mat[,1]))), lwd=2,
xlab="year", ylab="MSE of BLUE", main="25 year rolling prediction of next year's median rainfall")
lines(pred.mat[,2]~testyrs, type="b", lty=2, lwd=2)
legend("topleft", c("Full model", "6-var model"), lty=1:2, lwd=2)
save(SSPmat.d, "SSPmat_wild_ntothepoint1.txt")
save(SSPmat.d, file="SSPmat_wild_ntothepoint1.txt")
save(SSPmat.d, file="SSPmat_wild_ntothepoint1.rda")
