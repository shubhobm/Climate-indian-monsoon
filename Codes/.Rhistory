r = (y - Xbeta)/sqrt(1-p/n)
# loop for full model bootstrap
# to get bootstrap distribution of parameters
for(i in 1:nboot){
iyb = Xbeta + sdn*rnorm(n)*r
ibeta = Const.full %*% iyb
beta.mat[i,] = ibeta
}
## initialize some quantities
Const = list()
for(j in 1:p){
Xj = X[,-j]
Const[[j]] = solve(t(Xj) %*% Xj) %*% t(Xj)
}
## loop to get drop 1 bootstrap estimates
for(i in 1:nboot){
iyb = Xbeta + sdn*rnorm(n)*r
for(j in 1:p){
ibeta.j = Const[[j]] %*% iyb
# get depth-based criterion
ibeta.j.full = rep(0,p)
ibeta.j.full[-j] = ibeta.j
SSPmat.d[i,j] = mdepth.TD(t(as.matrix(ibeta.j.full)), beta.mat)$dep
#SSPmat.d[i,p+1] = 1/(1 + t(as.numeric(ibeta.j.full) - beta) %*% XtX.inv %*% (as.numeric(ibeta.j.full) - beta))
}
# for full model
ibeta = Const.full %*% iyb
SSPmat.d[i,p+1] = mdepth.TD(t(ibeta), beta.mat)$dep
#SSPmat.d[i,p+1] = 1/(1 + t(as.numeric(ibeta) - beta) %*% XtX.inv %*% (as.numeric(ibeta) - beta))
}
# get p-values
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1], paired=TRUE)$p.value
}
mod = glm.fit(x=X, y=y)
Cn.frame = data.frame(DroppedVar = c(paste("-", names(coef(mod))), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
n = nrow(X)
sdn = n^.2
#m = ceiling(n^(.5))
p = ncol(X)
nboot = 1e3
SSPmat = matrix(0, nrow=nboot, ncol=p+1)
SSPmat.d = SSPmat
beta.mat = matrix(0, nrow=nboot, ncol=p)
# make full model
XtX.inv = solve(t(X) %*% X)
Const.full = XtX.inv %*% t(X)
beta = Const.full %*% y
Xbeta = X %*% beta
r = (y - Xbeta)/sqrt(1-p/n)
# loop for full model bootstrap
# to get bootstrap distribution of parameters
for(i in 1:nboot){
iyb = Xbeta + sdn*rnorm(n)*r
ibeta = Const.full %*% iyb
beta.mat[i,] = ibeta
}
## initialize some quantities
Const = list()
for(j in 1:p){
Xj = X[,-j]
Const[[j]] = solve(t(Xj) %*% Xj) %*% t(Xj)
}
## loop to get drop 1 bootstrap estimates
for(i in 1:nboot){
iyb = Xbeta + sdn*rnorm(n)*r
for(j in 1:p){
ibeta.j = Const[[j]] %*% iyb
# get depth-based criterion
ibeta.j.full = rep(0,p)
ibeta.j.full[-j] = ibeta.j
SSPmat.d[i,j] = mdepth.TD(t(as.matrix(ibeta.j.full)), beta.mat)$dep
#SSPmat.d[i,p+1] = 1/(1 + t(as.numeric(ibeta.j.full) - beta) %*% XtX.inv %*% (as.numeric(ibeta.j.full) - beta))
}
# for full model
ibeta = Const.full %*% iyb
SSPmat.d[i,p+1] = mdepth.TD(t(ibeta), beta.mat)$dep
#SSPmat.d[i,p+1] = 1/(1 + t(as.numeric(ibeta) - beta) %*% XtX.inv %*% (as.numeric(ibeta) - beta))
}
# get p-values
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1], paired=TRUE)$p.value
}
mod = glm.fit(x=X, y=y)
Cn.frame = data.frame(DroppedVar = c(paste("-", names(coef(mod))), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
n = nrow(X)
sdn = n^.02
#m = ceiling(n^(.5))
p = ncol(X)
nboot = 1e3
SSPmat = matrix(0, nrow=nboot, ncol=p+1)
SSPmat.d = SSPmat
beta.mat = matrix(0, nrow=nboot, ncol=p)
# make full model
XtX.inv = solve(t(X) %*% X)
Const.full = XtX.inv %*% t(X)
beta = Const.full %*% y
Xbeta = X %*% beta
r = (y - Xbeta)/sqrt(1-p/n)
# loop for full model bootstrap
# to get bootstrap distribution of parameters
for(i in 1:nboot){
iyb = Xbeta + sdn*rnorm(n)*r
ibeta = Const.full %*% iyb
beta.mat[i,] = ibeta
}
## initialize some quantities
Const = list()
for(j in 1:p){
Xj = X[,-j]
Const[[j]] = solve(t(Xj) %*% Xj) %*% t(Xj)
}
## loop to get drop 1 bootstrap estimates
for(i in 1:nboot){
iyb = Xbeta + sdn*rnorm(n)*r
for(j in 1:p){
ibeta.j = Const[[j]] %*% iyb
# get depth-based criterion
ibeta.j.full = rep(0,p)
ibeta.j.full[-j] = ibeta.j
SSPmat.d[i,j] = mdepth.TD(t(as.matrix(ibeta.j.full)), beta.mat)$dep
#SSPmat.d[i,p+1] = 1/(1 + t(as.numeric(ibeta.j.full) - beta) %*% XtX.inv %*% (as.numeric(ibeta.j.full) - beta))
}
# for full model
ibeta = Const.full %*% iyb
SSPmat.d[i,p+1] = mdepth.TD(t(ibeta), beta.mat)$dep
#SSPmat.d[i,p+1] = 1/(1 + t(as.numeric(ibeta) - beta) %*% XtX.inv %*% (as.numeric(ibeta) - beta))
}
# get p-values
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1], paired=TRUE)$p.value
}
mod = glm.fit(x=X, y=y)
Cn.frame = data.frame(DroppedVar = c(paste("-", names(coef(mod))), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
summary(lm(medv~., Boston))
sdn = n^.01
sdn
n = nrow(X)
sdn = n^.01
#m = ceiling(n^(.5))
p = ncol(X)
nboot = 1e3
SSPmat = matrix(0, nrow=nboot, ncol=p+1)
SSPmat.d = SSPmat
beta.mat = matrix(0, nrow=nboot, ncol=p)
# make full model
XtX.inv = solve(t(X) %*% X)
Const.full = XtX.inv %*% t(X)
beta = Const.full %*% y
Xbeta = X %*% beta
r = (y - Xbeta)/sqrt(1-p/n)
# loop for full model bootstrap
# to get bootstrap distribution of parameters
for(i in 1:nboot){
iyb = Xbeta + sdn*rnorm(n)*r
ibeta = Const.full %*% iyb
beta.mat[i,] = ibeta
}
## initialize some quantities
Const = list()
for(j in 1:p){
Xj = X[,-j]
Const[[j]] = solve(t(Xj) %*% Xj) %*% t(Xj)
}
## loop to get drop 1 bootstrap estimates
for(i in 1:nboot){
iyb = Xbeta + sdn*rnorm(n)*r
for(j in 1:p){
ibeta.j = Const[[j]] %*% iyb
# get depth-based criterion
ibeta.j.full = rep(0,p)
ibeta.j.full[-j] = ibeta.j
SSPmat.d[i,j] = mdepth.TD(t(as.matrix(ibeta.j.full)), beta.mat)$dep
#SSPmat.d[i,p+1] = 1/(1 + t(as.numeric(ibeta.j.full) - beta) %*% XtX.inv %*% (as.numeric(ibeta.j.full) - beta))
}
# for full model
ibeta = Const.full %*% iyb
SSPmat.d[i,p+1] = mdepth.TD(t(ibeta), beta.mat)$dep
#SSPmat.d[i,p+1] = 1/(1 + t(as.numeric(ibeta) - beta) %*% XtX.inv %*% (as.numeric(ibeta) - beta))
}
# get p-values
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1], paired=TRUE)$p.value
}
mod = glm.fit(x=X, y=y)
Cn.frame = data.frame(DroppedVar = c(paste("-", names(coef(mod))), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
names(X)
head(X)
?Boston
summary(lm(medv~., Boston[,-c(3,5)]))
names(X)
head(X)
summary(lm(medv~., Boston[,-c(3,5,7)]))
summary(lm(medv~., Boston))
cor(X)
View(Boston)
nsamp = 1e3
p = ncol(X)
SSPmat.d = matrix(0, nrow=nsamp, ncol=p+1)
XtX = t(X) %*% X
XtX.inv = solve(XtX)
beta.hat = XtX.inv %*% t(X) %*% y
sig2 = mean((y - X %*% beta.hat)^2)
beta.mat = my.mvrnorm(nsamp, beta.hat, sig2*XtX.inv)
SSPmat.d[,p+1] = mdepth.TD(beta.mat, beta.mat)$dep
#diffmat = beta.mat - t(beta.hat %*% rep(1,nsamp))
#SSPmat.d[,p+1] = 1/(1 + diag(diffmat %*% XtX %*% t(diffmat)))
## initialize some quantities
for(i in 1:p){
ibeta.mat = matrix(0, nrow=nsamp, ncol=p)
ibeta.hat = rep(0, p)
iX = X[,-i]
iXtX = t(iX) %*% iX
iXtX.inv = solve(iXtX)
iV = XtX.inv[-i,-i] - outer(XtX.inv[-i,i], XtX.inv[-i,i]) * XtX.inv[i,i]
ibeta.hat[-i] = iXtX.inv %*% t(iX) %*% y
isig2 = mean((y - iX %*% ibeta.hat[-i])^2)
ibeta.mat[,-i] = my.mvrnorm(nsamp, ibeta.hat[-i], isig2*iV)
SSPmat.d[,i] = mdepth.TD(ibeta.mat, beta.mat)$dep
#  idiffmat = ibeta.mat - t(beta.hat %*% rep(1,nsamp))
#  SSPmat.d[,i] = 1/(1 + diag(idiffmat %*% XtX %*% t(idiffmat)))
}
# get p-values
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1], paired=TRUE)$p.value
}
mod = glm.fit(x=X, y=y)
Cn.frame = data.frame(DroppedVar = c(paste("-", names(coef(mod))), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
nsamp = 1e3
p = ncol(X)
SSPmat.d = matrix(0, nrow=nsamp, ncol=p+1)
XtX = t(X) %*% X
XtX.inv = solve(XtX)
beta.hat = XtX.inv %*% t(X) %*% y
sig2 = mean((y - X %*% beta.hat)^2)
beta.mat = my.mvrnorm(nsamp, beta.hat, sig2*XtX.inv)
SSPmat.d[,p+1] = mdepth.TD(beta.mat, beta.mat)$dep
#diffmat = beta.mat - t(beta.hat %*% rep(1,nsamp))
#SSPmat.d[,p+1] = 1/(1 + diag(diffmat %*% XtX %*% t(diffmat)))
## initialize some quantities
for(i in 1:p){
ibeta.mat = matrix(0, nrow=nsamp, ncol=p)
ibeta.hat = rep(0, p)
iX = X[,-i]
iXtX = t(iX) %*% iX
iXtX.inv = solve(iXtX)
iV = XtX.inv[-i,-i] - outer(XtX.inv[-i,i], XtX.inv[-i,i]) * XtX.inv[i,i]
ibeta.hat[-i] = iXtX.inv %*% t(iX) %*% y
isig2 = mean((y - iX %*% ibeta.hat[-i])^2)
ibeta.mat[,-i] = my.mvrnorm(nsamp, ibeta.hat[-i], isig2*iV)
SSPmat.d[,i] = mdepth.TD(ibeta.mat, beta.mat)$dep
#  idiffmat = ibeta.mat - t(beta.hat %*% rep(1,nsamp))
#  SSPmat.d[,i] = 1/(1 + diag(idiffmat %*% XtX %*% t(idiffmat)))
}
# get p-values
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1], paired=TRUE)$p.value
}
mod = glm.fit(x=X, y=y)
Cn.frame = data.frame(DroppedVar = c(paste("-", names(coef(mod))), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
nsamp = 1e3
p = ncol(X)
SSPmat.d = matrix(0, nrow=nsamp, ncol=p+1)
XtX = t(X) %*% X
XtX.inv = solve(XtX)
beta.hat = XtX.inv %*% t(X) %*% y
sig2 = mean((y - X %*% beta.hat)^2)
beta.mat = my.mvrnorm(nsamp, beta.hat, sig2*XtX.inv)
SSPmat.d[,p+1] = mdepth.TD(beta.mat, beta.mat)$dep
#diffmat = beta.mat - t(beta.hat %*% rep(1,nsamp))
#SSPmat.d[,p+1] = 1/(1 + diag(diffmat %*% XtX %*% t(diffmat)))
## initialize some quantities
for(i in 1:p){
ibeta.mat = matrix(0, nrow=nsamp, ncol=p)
ibeta.hat = rep(0, p)
iX = X[,-i]
iXtX = t(iX) %*% iX
iXtX.inv = solve(iXtX)
iV = XtX.inv[-i,-i] - outer(XtX.inv[-i,i], XtX.inv[-i,i]) * XtX.inv[i,i]
ibeta.hat[-i] = iXtX.inv %*% t(iX) %*% y
isig2 = mean((y - iX %*% ibeta.hat[-i])^2)
ibeta.mat[,-i] = my.mvrnorm(nsamp, ibeta.hat[-i], isig2*iV)
SSPmat.d[,i] = mdepth.TD(ibeta.mat, beta.mat)$dep
#  idiffmat = ibeta.mat - t(beta.hat %*% rep(1,nsamp))
#  SSPmat.d[,i] = 1/(1 + diag(idiffmat %*% XtX %*% t(idiffmat)))
}
# get p-values
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1], paired=TRUE)$p.value
}
mod = glm.fit(x=X, y=y)
Cn.frame = data.frame(DroppedVar = c(paste("-", names(coef(mod))), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
nsamp = 1e4
p = ncol(X)
SSPmat.d = matrix(0, nrow=nsamp, ncol=p+1)
XtX = t(X) %*% X
XtX.inv = solve(XtX)
beta.hat = XtX.inv %*% t(X) %*% y
sig2 = mean((y - X %*% beta.hat)^2)
beta.mat = my.mvrnorm(nsamp, beta.hat, sig2*XtX.inv)
SSPmat.d[,p+1] = mdepth.TD(beta.mat, beta.mat)$dep
#diffmat = beta.mat - t(beta.hat %*% rep(1,nsamp))
#SSPmat.d[,p+1] = 1/(1 + diag(diffmat %*% XtX %*% t(diffmat)))
## initialize some quantities
for(i in 1:p){
ibeta.mat = matrix(0, nrow=nsamp, ncol=p)
ibeta.hat = rep(0, p)
iX = X[,-i]
iXtX = t(iX) %*% iX
iXtX.inv = solve(iXtX)
iV = XtX.inv[-i,-i] - outer(XtX.inv[-i,i], XtX.inv[-i,i]) * XtX.inv[i,i]
ibeta.hat[-i] = iXtX.inv %*% t(iX) %*% y
isig2 = mean((y - iX %*% ibeta.hat[-i])^2)
ibeta.mat[,-i] = my.mvrnorm(nsamp, ibeta.hat[-i], isig2*iV)
SSPmat.d[,i] = mdepth.TD(ibeta.mat, beta.mat)$dep
#  idiffmat = ibeta.mat - t(beta.hat %*% rep(1,nsamp))
#  SSPmat.d[,i] = 1/(1 + diag(idiffmat %*% XtX %*% t(idiffmat)))
}
# get p-values
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1], paired=TRUE)$p.value
}
mod = glm.fit(x=X, y=y)
Cn.frame = data.frame(DroppedVar = c(paste("-", names(coef(mod))), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
nsamp = 1e4
p = ncol(X)
SSPmat.d = matrix(0, nrow=nsamp, ncol=p+1)
XtX = t(X) %*% X
XtX.inv = solve(XtX)
beta.hat = XtX.inv %*% t(X) %*% y
sig2 = mean((y - X %*% beta.hat)^2)
beta.mat = my.mvrnorm(nsamp, beta.hat, sig2*XtX.inv)
SSPmat.d[,p+1] = mdepth.TD(beta.mat, beta.mat)$dep
#diffmat = beta.mat - t(beta.hat %*% rep(1,nsamp))
#SSPmat.d[,p+1] = 1/(1 + diag(diffmat %*% XtX %*% t(diffmat)))
## initialize some quantities
for(i in 1:p){
ibeta.mat = matrix(0, nrow=nsamp, ncol=p)
ibeta.hat = rep(0, p)
iX = X[,-i]
iXtX = t(iX) %*% iX
iXtX.inv = solve(iXtX)
iV = XtX.inv[-i,-i] - outer(XtX.inv[-i,i], XtX.inv[-i,i]) * XtX.inv[i,i]
ibeta.hat[-i] = iXtX.inv %*% t(iX) %*% y
isig2 = mean((y - iX %*% ibeta.hat[-i])^2)
ibeta.mat[,-i] = my.mvrnorm(nsamp, ibeta.hat[-i], isig2*iV)
SSPmat.d[,i] = mdepth.TD(ibeta.mat, beta.mat)$dep
#  idiffmat = ibeta.mat - t(beta.hat %*% rep(1,nsamp))
#  SSPmat.d[,i] = 1/(1 + diag(idiffmat %*% XtX %*% t(idiffmat)))
}
# get p-values
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1], paired=TRUE)$p.value
}
mod = glm.fit(x=X, y=y)
Cn.frame = data.frame(DroppedVar = c(paste("-", names(coef(mod))), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
source('C:/Study/My projects/Climate-indian monsoon/Codes/lmselect_bmd_fiducial.R')
t = data.frame(apply(SSPmat.d, 2, mean))
rownames(t) = c(varnames,"full")
t
rm(list=ls())
#setwd("\\\\dfs.com/root/Dept-Decision/Dept-Users/Majumdar/Rain")
setwd('C:/Study/My projects/Climate-indian monsoon/Codes')
source('misc_functions.R')
library(rrcov)
library(fda.usc)
library(lme4)
library(MuMIn)
# read in data
rainsmall = read.csv("../data/rainsmall.csv")
# check full model
rainsmall[-(1:3)] = scale(rainsmall[-(1:3)])
varnames = names(rainsmall)[-(1:3)]
formula = paste(varnames, collapse="+")
formula = as.formula(paste("log(PRCP+1) ~", formula, "+ (1|year)"))
mod.full = lmer(formula, data=rainsmall)
summary(mod.full)
anova(mod.full)
r.squaredGLMM(mod.full)
t = data.frame(apply(SSPmat.d, 2, mean))
rownames(t) = c(varnames,"full")
load("C:/Study/My projects/Climate-indian monsoon/Codes/SSPmat_wild_ntothepoint1.rda")
t = data.frame(apply(SSPmat.d, 2, mean))
rownames(t) = c(varnames,"full")
t
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1])$p.value
}
Cn.frame = data.frame(DroppedVar = c(paste("-", names(data.frame(x))[-1]), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
n = nrow(rainsmall)
nr = length(eta)
p = ncol(rainsmall)-3
sdn = n^(.05)
sdr = nr^(.05)
rainsmall[-(1:3)] = scale(rainsmall[-(1:3)])
varnames = names(rainsmall)[-(1:3)]
formula = paste(varnames, collapse="+")
random_terms = "+ (1|year)"
formula = as.formula(paste("log(PRCP+1) ~", formula, random_terms))
mod.full = lmer(formula, data=rainsmall)
summary(mod.full)
anova(mod.full)
r.squaredGLMM(mod.full)
# set up residuals
y = getME(mod.full, 'y')
fixed = getME(mod.full, 'X') %*% fixef(mod.full)
eta = unlist(ranef(mod.full))
Z = t(as.matrix(getME(mod.full,'Zt')))
random = Z %*% eta
r = y - fixed - random
# bootstrap parameters
n = nrow(rainsmall)
nr = length(eta)
p = ncol(rainsmall)-3
sdn = n^(.05)
sdr = nr^(.05)
pVal = rep(1, p+1)
for(i in 1:p){
pVal[i] = t.test(SSPmat.d[,i], SSPmat.d[,p+1])$p.value
}
Cn.frame = data.frame(DroppedVar = c(paste("-", names(data.frame(x))[-1]), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
names(getME(mod.full, 'X'))
head(getME(mod.full, 'X'))
x = getME(mod.full, 'X')
Cn.frame = data.frame(DroppedVar = c(paste("-", names(data.frame(x))[-1]), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
Cn.frame = data.frame(DroppedVar = c(paste("-", names(data.frame(getME(mod.full, 'X')))[-1]), "<none>"),
Cn = apply(SSPmat.d, 2, mean),
pValue = pVal)
Cn.frame = Cn.frame[with(Cn.frame, order(Cn)),]
row.names(Cn.frame) = NULL
Cn.frame
depth = matrix(nrow=101, ncol=1); j = depth
for(i in 1:101){
x = rnorm(1000); sq = sqrt(1000)
j[i] = (i-51)/10
depth[i] = max(1 - pnorm(sq*(mean(x)-j)/sd(x)),1 - pnorm(sq*(mean(x)+j)/sd(x)))
}
depth
plot(density(depth))
MJO = read.table("../data/madden_julien_1978_2015.txt", header=T)
names(MJO)
head(MJO)
